

CREDIT gfan
  Gfan is a software package for computing Groebner fans and tropical varieties.
  Copyright by Anders Jensen
  http://www.math.tu-berlin.de/~jensen/software/gfan/gfan.html

# path to gfan
custom $gfan_tropicalbruteforce;

CONFIGURE {
    find_program($gfan_tropicalbruteforce, "gfan_tropicalbruteforce");
}


#######################################
#######################################
###
### Toric Variety
###
#######################################
#######################################

declare object ToricVariety<Scalar=Rational [ typechecks::is_ordered_field(Scalar) ]> : PolyhedralFan<Scalar>; 

object PolyhedralFan<Rational> {

	auto_cast : ToricVariety<Rational>;

}

object ToricVariety {

	# Properties:

	property AFFINE : Bool;

	property PROJECTIVE : Bool;

	property SMOOTH = override SMOOTH_FAN;
	
	# Rules:

	rule PROJECTIVE : MAXIMAL_CONES {
		$this->PROJECTIVE = 1;
	}
	
}

#######################################
#######################################
###
### Hypersurface in Toric Variety
###
#######################################
#######################################

declare object HypersurfaceInTV;

object HypersurfaceInTV {

	# Properties:
	
	property EQUATION : Polynomial;

	property EXPONENTS : Matrix<Int>;

	property COEFFICIENTS : Vector<Rational>;

	property TROPICAL : TropicalVariety;

	property TROPICAL_FAN : PolyhedralFan;
	
	# Rules:
	
	# It would be nice to have the opposite rules as well. TODO
	rule EQUATION : EXPONENTS, COEFFICIENTS {
		my $nvars = $this->EXPONENTS->cols();
        	my @vars = (map { "x$_" } (1..$nvars) );
        	my $R = new Ring(@vars);
        	$this->EQUATION = new Polynomial($this->EXPONENTS,$this->COEFFICIENTS,$R);
	}
	
	# Note that this method first homogenizes the input polynome
	# and that the output fan is not 'dehomogenized', yet. Also this
	# is only right up to sign, i.e. min or max in the tropical
	# language. I think for the Sturmfels/Maclagan Theorem to hold
	# the sign has to be changed.
	rule TROPICAL_FAN : EXPONENTS, COEFFICIENTS {
		$this->TROPICAL_FAN = gfan_tropicalbruteforce($this->COEFFICIENTS, $this->EXPONENTS);
	}

}

# This program preprocesses the input for gfan and then reads in the gfan output.
# It should be checked whether gfan_groebnerbla can really be left out.
sub gfan_tropicalbruteforce {
	my ($coefficients, $exponents) = @_;
	my $tempfile=new Tempfile;
	#my $tempfile="test";
	
	# Homogenizing polynomial and preparing to write to file:	
	my $nvars = $exponents->cols();
	my @vars = ( "t" , map { "x$_" } (1..$nvars) );
	my $one = ones_vector<Int>($nvars);
	my $degrees = $exponents*$one;
	my $homog = new Matrix<Int>[[map{maximum($degrees)-$degrees->[$_]} (0..($exponents->rows()-1))]];
	print $homog;
	my $newexp = transpose($homog)|$exponents;
	my $R = new Ring(@vars);
	my $p = new Polynomial($newexp,$coefficients,$R); 
	
	# Writing data to file:
	open(my $input, ">$tempfile.in") or die "Can't create temporary file $tempfile.in: $!";
	print $input "Q[";
	print $input join(",",$R->variables);
	print $input "]{\n";
	print $input $p;
	print $input "\n}";
	print $tempfile;
	close $input;
	
	# Accessing gfan:
	system "$gfan_tropicalbruteforce --xml <$tempfile.in >$tempfile.poly 2>/dev/null";
	
	my $gfan_out= User::load("$tempfile.poly");
	return $gfan_out;
}

# This program preprocesses the input for gfan and then reads in the gfan output.
# It should be checked whether gfan_groebnerbla can really be left out.
sub gfan_tropicalhypersurface {
	my ($coefficients, $exponents) = @_;
	my $tempfile=new Tempfile;
	#my $tempfile="test";
	
	# Homogenizing polynomial and preparing to write to file:	
	my $nvars = $exponents->cols();
	my @vars = ( map { "x$_" } (1..$nvars) );
	my $R = new Ring(@vars);
	my $p = new Polynomial($exponents,$coefficients,$R); 
	
	# Writing data to file:
	open(my $input, ">$tempfile.in") or die "Can't create temporary file $tempfile.in: $!";
	print $input "Q[";
	print $input join(",",$R->variables);
	print $input "]{\n";
	print $input $p;
	print $input "\n}";
	print $tempfile;
	close $input;
	
	# Accessing gfan:
	system "$gfan_tropicalhypersurface --xml <$tempfile.in >$tempfile.poly 2>/dev/null";
	
	my $gfan_out= User::load("$tempfile.poly");
	return $gfan_out;
}

user_function add_ray(PolyhedralFan, Vector){
	my($fan, $ray) = @_;
	my $oldrays = $fan->RAYS;
	my $newrays = $oldrays / $ray;
	print $newrays;
	my $mc = $fan->MAXIMAL_CONES;
	for my $f (@$mc) {
		print "$f\n";
		my $gens = new Matrix<Rational>(@$oldrays[@$f]);
		print $gens;	
	}	
}

user_function cocoref_bruteforce(Matrix) {
	my($rays) = @_;
	my $dim = $rays->cols();
	my $m = $rays->rows();
	my @init_cones = all_subsets_of_k($dim, 0..($m)-1);
	@init_cones = map(new Set($_), @init_cones);
	print @init_cones;
	my @new_cones = ();
	foreach my $c (@init_cones){
		my $A = new Matrix<Rational>(@$rays[@$c]);
		if(rank($A)==$dim){
			my $iA = inv($A);
			my $eval = $rays * $iA;
			my $v = new Vector<Rational>(map(minimum($_), @$eval));
			#print $v;
			my $contained_rays = 0;
			map($_>=0?$contained_rays++:0, @$v);
			#print "$contained_rays\n";
			if($contained_rays == $dim){
				push @new_cones, new Cone<Rational>(INPUT_RAYS=>$A);
				#print "$c\n";	
			}
		}
	}

	# Refinement procedure:
	my $repeat = 1;
	my $num = 0;
	my @old_cones = @new_cones;
	my @collected = @new_cones;
	my $in = @old_cones;
	print "old: $in\n";
	while ($repeat == 1) {
		$repeat =0;
		my @toadd = ();
		foreach my $A (@old_cones){
			foreach my $B (@new_cones){
				if(!included_polyhedra($A, $B) && !included_polyhedra($B, $A)){
					my $AB = intersection($A, $B);
					if ($AB->DIM == $dim){
						my $isnew = 1;
						foreach my $C (@collected,@toadd){
							if(equal_polyhedra($AB, $C)){
								$isnew = 0;
								last;
							}
						}
						if($isnew == 1){
							$repeat = 1;
							push @toadd, $AB;
						}
					}
				}
			}
			my $s = @toadd;
			print "$s\n";
		}
		if($repeat == 1){
			@new_cones = @toadd;
			@collected = (@collected, @toadd);
			my $s = @collected;
			print "size: $s\n";
		}
	}

	# Removing superflous cones:
	my @keep = ();
	foreach my $A (@collected){
		my $check = 1;
		foreach my $B (@collected){
			if(included_polyhedra($B, $A) && !equal_polyhedra($A, $B)){
				$check = 0;
				last;
			}
		}
		if($check == 1){
			push @keep, $A;
		}
	}
	
	$in = @keep;
	print "Number of resulting cones: $in.\n";
	
	my @rays = ();
	#print @keep;
	foreach my $C (@keep){
		my $r = new Matrix<Rational>($C->RAYS);
		@rays = (@rays, map(primitive($_), @$r));
	}
	#print @rays;
	my $ray_set = new Set<Vector>(@rays);
	#print $ray_set;
	
	my @gens = @$ray_set;
	my $gs = @gens;
	my $rays = new Matrix<Rational>(@gens);
	#print $rays;
	my $ray_map = new Map<Vector, Int>;
	map($ray_map->{$gens[$_]}=$_, 0..($gs-1));
	my @max_cones;
	foreach my $C (@keep){
		my $r = new Matrix<Rational>($C->RAYS);
		my @mc = map($ray_map->{primitive($_)}, @$r);
		push @max_cones, new Set<Integer>(@mc);
	}
	print "Generating rays:\n";
	print $rays;
	print "\nMaximal cones:\n";
	print "@max_cones\n";
	return check_fan($rays, new Array< Set<Integer>>(@max_cones));
}

user_function required_cones(Polynomial, ToricVariety){
	my ($g, $TV) = @_;
	
}

sub homogenize { 
	my ($in) = @_;
	
}

sub gale_dual{
	# TODO
	return 0;
}
